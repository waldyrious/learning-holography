<!DOCTYPE html>
<html>
<head>
	<title>PH CGH formulas | Learning Holography</title>
	<link href="css/base-style.css" rel="stylesheet">
	<meta charset="utf-8">
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
		tex2jax: { inlineMath: [['$','$'],['\\(','\\)']] },
		TeX: { equationNumbers: { autoNumber: "AMS" } }
	  });
	</script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>-->
  </head>
  <body>

<a href="index.html">&larr; back</a>

<h2>Step-by-step derivation of the physically-based computer-generated hologram formula</h2>

<p class="note"><b>Note:</b> This guide assumes the reader already knows
<a href="http://en.wikipedia.org/wiki/Holography">what a hologram is</a>
and, in broad terms, the basic principles of how to make one.</p>

<p>Let's say we have a 3D object,
and we want to make a computer-generated hologram from it.
To do that, we first decompose the object into a large number of points,
which we approximate as spherical light sources.
(For now, we'll ignore the opacity of the object.
This means that the points near the holographic plate
don't block the light from the farther ones).</p>
<img src="img/stanford-bunny.png" width="240px" style="vertical-align:middle;">
<b style="font-size:x-large">➔</b>
<img src="img/stanford-bunny-points.png" width="220px" style="vertical-align:middle;">

<p>The light from all these points will compose what we'll call
the <i>object wave</i>, which has a very complex shape.
But to make the hologram, we also need a (much simpler) <i>reference wave</i>,
which will act as the "key" to later decode the interference pattern
that will result from the mix of both waves hitting the holographic plate,
and thus reconstruct the 3D image from the hologram.</p>

<p>The reference wave we'll use is a plane wave, which means it can be thought of
as a series of parallel planes, spread apart by the wavelength $\lambda$,
each corresponding to a crest in the reference wave.</p>
<p style="text-align:center"><img src="img/plane-wave.svg" width="400"></p>

<p>Our system of coordinates to describe the 3D space will be the
<a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness">left-handed Cartesian</a>,
with X pointing to the right, Y pointing up, and Z pointing forward (from the object to the hologram).
The holographic plate will be a rectangular area centered at the origin of the system of coordinates,
and perpendicular to the Z axis (i.e., it will be contained the XY plane).</p>
</p>
Given the above, we'll define the following basic elements for our calculations:
<ul>
	<li>$h = (h_x, h_y, 0)$, a point on the hologram plane ($z = 0$), and</li>
	<li>$p_n = (p_{nx}, p_{ny}, p_{nz})$, the location of the $n^{th}$ object point light source.</li>
</ul>

<p style="text-align:center"><img src="img/scene.svg" width="500"></p>
<!-- Note: subscripts, such as p_n in this image,
  -- (using baseline-shift="sub") aren't supported in Firefox yet
  -- see https://bugzilla.mozilla.org/show_bug.cgi?id=308338
  -->

<h3>Step 1: Building the object wave</h3>

To start, let's recall, as <a href="wave-propagation.html">previously described</a>,
that the oscillation of a light wave generated by a point light source,
at instant $t$, can be described with:

\[
A \times \cos(\omega t - \varphi)
\]

<p>...where $A$ is the amplitude (maximum height) of the oscillation,
$\omega$ is the <i>temporal angular frequency</i> of the wave
(i.e. how many cycles, in radians, the wave completes per unit of time)
and $\varphi$ is the initial phase (angle at $t=0$) of the wave
at the point where we're measuring it.</p>

<!--<p class="note"><b>Note:</b> although the amplitude of the wave does depend on the distance r from the source
where the wave is being measured, the results for the purpose of the hologram would be just
a lighter or darker image, so for simplicity's sake we'll ignore attenuation
and just use $A$ instead of $A(r)$, i.e. assume the amplitude remains constant.</p>-->

<p>Using this formulation, the amplitude of the whole compound object wave,
made up of all $N$ object points,
at a given point $h$ of the hologram and a given time $t$,
is given by simply summing all contributions together:</p>

\[
obj(h,t)=\sum_n A_n \cos(\omega t - \varphi_n)
\]

The value of $\varphi_n$ at point $h$ depends on the distance from the object point
to the hologram point being considered, which is calculated
using the familiar <a href="http://en.wikipedia.org/wiki/Euclidean_distance">
Euclidean distance</a> formula:

\[
r_n(h) = \sqrt{(p_{nx} - h_x)^2 + (p_{ny} - h_y)^2 + {p_{nz}}^2}
\]

<p>(remember that $h_z$ is zero, because we placed the hologram plane at $z=0$).</p>

<p>This distance (called "r" to underline its meaning as the <em>radius</em>
of the light sphere emitted from the $n^{th}$ point)
is then multiplied by the <i>spatial angular frequency</i> of the wave
(i.e. how many cycles, in radians, the wave completes per unit of distance),
which is abbreviated as $k = \tau/\lambda$, and —somewhat unhelpfully—
called the "wavenumber".</p>

<p class="note"><b>Note:</b> In this guide, we'll use $\tau$ as a symbol for $2\pi$,
for the reasons described in the <a href="http://tauday.com/tau-manifesto">Tau Manifesto</a>.</p>

<p>This multiplication, $k \times r_n(h)$,
like the $\omega \times t$ one, yields a phase angle, so both values can be
subtracted to yield the phase of the wave $p_n$ at point $h$ and instant $t$.</p>

<!--
<p>Note that here we're considering that the wave is leaving each object point
at phase zero, which is not how things would really play out in the real world.
Remember how in the beginning whe said that the object points will be <i>approximated</i>
as spherical light sources? Well, in reality, the object would not emit light by itself, of course,
but instead it would reflect the light that hits it, which in the case of a hologram
is the reference wave.</p>

<p>Assuming perfect reflection (like a mirror), the initial phase at the object
point will depend on its position along the direction of propagation of the wave,
and consequently the initial phase at the hologram point will depend on this as well.
Ideally we would subtract it, as in $k r_n(h) - \varphi_{n0}$,
which would return the exact phase reflected by the object point.</p>

<p>However, we usually don't want perfectly polished, mirror-like surfaces.</p>

<p>(in CGH) you can replace a plane by a set of point light sources (reflectors) lying geometrically exactly on this plane.
By making phase change 0 (i.e. reflected light has the same phase like the incident light), you simulate a perfect mirror.
By making phase change randomly between -pi and +pi, you simulate a rough (matte) surface.
Of course, ideally you should simulate a rough surface by offsetting points randomly by tiny amounts,
but phase change has virtually the same effect and is much more convenient to use.</p>
-->

The object wave formula then becomes:

\begin{equation}
	obj(h,t)=\sum_n A_n \cos(\omega t - k r_n(h))
	\label{eq:obj}
\end{equation}

Note how the duality of this generic formula can be exploited, on the one hand,
to calculate both the variation of the object wavefront in space
(i.e. across the hologram), at a given instant frozen in time,
by varying $h$ and keeping $t$ constant, and, on the other hand,
to calculate the variation of the object wavefront at a fixed
hologram point, by varying $t$ and keeping $h$ constant.

<h3>Step 2: Adding the reference wave</h3>
<!-- Note: the R subscript for the reference wave
  -- is done using a small capital R, i.e. ʀ (U+0280),
  -- which plays better visually with the lowercase subscript of the object wave(s).
  -- Inserting the character directly in the source in HTML+MathJax works,
  -- but in pure latex, this would likely be done through the IPA package \usepackage{tipa}
  -- and the command \textscr. Not sure if it works in math mode, though.
  -->

<p>As may be noted, the above formula is just for the compound object wave.
We still need to add the reference wave
to get the final wavefront that will form the hologram.</p>

<p>As mentioned above, we'll be using a planar wave as the reference wave
(which makes some calculations simpler and some practical setups easier),
so it's not useful to describe it with the spherical wave formula,
because by definition, a planar wave is the idealized limit of a spherical wave
as its source point's distance from the measuring region grows toward infinity,
with the local curvature of its wavefronts consequently approaching zero.
What we do, instead, is define it
by the angles it makes with the hologram plane, since these will be constant.</p>

<p>This is done using two angles: $\theta_y$, aka "yaw",
which represents the planar wave's rotation
around the (vertical) Y axis (like a head turning side to side),
and $\theta_x$, aka "pitch", which represents its rotation
around the (horizontal) X axis (like a head nodding up and down).<p>

<p>Let's start by considering $\theta_x=0$ and seeing what happens as we change $\theta_y$:</p>

<p style="text-align:center"><img src="img/plane-wave-projection.svg" width="400"></p>
<!-- Note: subscripts, such as λ_x and θ_y in this image,
  -- (using baseline-shift="sub") aren't supported in Firefox yet
  -- see https://bugzilla.mozilla.org/show_bug.cgi?id=308338
  -->

<!--<p class="note">This image shows a top-down view of the scene,
assuming the reference wave only changes in "yaw",
so a series of wavefronts, despite being planes,
would be seen as parallel lines from the top.</p>-->

<p>As can be seen in the image, if we adjust the angle $\theta_y$,
although the wavelength $\lambda$ would remain the same,
the distance between two wave crests <i>in the hologram plane</i> would change accordingly.
In other words, this distance is the projection of $\lambda$ into the X axis.
We'll call this $\lambda_x$.</p>

<p>Using elementary trigonometry, we can see that,
from the definition of the sine of an angle
as <a href="http://en.wikipedia.org/wiki/Trigonometry#Mnemonics">opposite/hypotenuse</a>,
we obtain the relationship $\sin(\theta_y) = \lambda/\lambda_x$,
and therefore, $\lambda_x = \lambda/\sin(\theta_y)$.</p>

<p>Now, having the projected wavelength of the reference wave along the hologram plane,
we can, for every location $h_x$, obtain the value of the wave (i.e. its phase).
For example, assuming the wave's phase at $h_x=0$ is zero,
the wave completes a full cycle (i.e. its phase is also zero)
at $h_x=\lambda_x$, and again at $2 \lambda_x$, $3 \lambda_x$, etc.
So, to get the reference wave phase at any given $h_x$,
we just divide it by $\lambda_x$.</p>

<p>Of course, this gives us a fractional value,
a linearly growing value representing the number of cycles completed as we advance $h_x$.
To pass this value to the cosine function
and thus get the amplitude of the wave, we need to convert this to radians,
which we do by multiplying the fractional value by $\tau$.
The formula for a (yaw-varying only) reference wave is thus:</p>

\[
A_ʀ \cos ( \omega t - \frac{h_x}{\lambda_x} \tau )
\]

<p>The same reasoning can be made for the case where we vary $\theta_x$
and keep $\theta_y=0$ — we obtain $\lambda_y = \lambda / \sin(\theta_x)$.
So putting it all together, for the general case where both $\theta_x \neq 0$ and $\theta_y \neq 0$:</p>

\[
A_ʀ \cos \left[ \omega t - \left( \frac{h_x}{\lambda/\sin(\theta_y)} \tau + \frac{h_y}{\lambda/\sin(\theta_x)} \tau \right) \right]
\]

By rearranging the pieces, and because $k=\tau/\lambda$, this simplifies to:

\[
A_ʀ \cos \left[ \omega t - k \left( h_x \sin(\theta_y) + h_y \sin(\theta_x) \right) \right]
\]

To make this similar to the object wave function,
we can abstract away the inner sum that's multiplied by $k$
into a function $p_ʀ$ (named that way to stress its meaning
as the <em>projection</em> of the reference wave into the hologram plane):

\[
p_ʀ(h) = \left( h_x \sin(\theta_y) + h_y \sin(\theta_x) \right)
\]

thus yielding the reference wave formula:

\begin{equation}
	ref(h,t)=A_ʀ \cos ( \omega t - k p_ʀ(h) )
	\label{eq:ref}
\end{equation}

<h3>Step 3: Putting the pieces together</h3>

Ok, now that we have the object and the reference wave described as simple formulas,
we can compute the hologram.
To do that, we simply go over each point $h$ in the hologram,
and sum the object and the reference waves,
obtaining the interference field $E$:

\[
E(h) = obj(h) + ref(h)
\]

which, when combined with equations \eqref{eq:obj} and \eqref{eq:ref}, expands to:

\begin{equation}
	E(h) = \sum_n A_n \cos(\omega t - k r_n(h)) + A_ʀ \cos ( \omega t - k p_ʀ(h) )
	\label{eq:interference}
\end{equation}

<p>However, this only gives us the instantaneous interference pattern
created from the interaction of all these waves at a given moment $t$.
The actual hologram is the result of the static "nodes" that appear over time
when coherent waves interact. These nodes will always have zero activity,
while other points in the hologram will register oscillations.
The image below illustrates this effect.</p>

<p style="text-align:center"><img src="img/standing-wave.gif"></p>

<p>Such nodes form whenever several waves of the same (constant) frequency interact.
In fact, this is exactly the principle that allows holograms to exist,
as static snapshots of a dynamic interference pattern.
To gain a better understanding of how these nodes form,
play a little with the animation at <a href="2d-hologram-viz.html">this page</a>.</p>

<p>Now, although these oscillations have all the same period, because the waves are coherent,
their peaks and valleys will occurr at different stages of the "global" cycle.
And each of these oscillation zones will have the value zero at the right time in their cycle.
So that makes it <b>impossible, in an instant snapshot, to distinguish permanently static zones
from zones that only happen to be passing through zero at that moment</b>.</p>

<p>To solve this, we have to calculate the interference pattern
for all possible phase positions of the global cycle and accumulate any activity,
to make the oscillation zones unambiguously distinguishable from the static nodes
of the interference pattern.</p>

<p>The straightforward way to do that is to discretize the phase space
into a finite set of regularly-spaced phase values,
calculate the instantaneous interference pattern at each phase value, and sum them all
to yield the cumulative interference pattern, a.k.a. the hologram.</p>

<p>Now, "discretize the phase space" may sound fancy,
but in practice, this is equivalent to calculating the instantaneous intensity
for all instants contained in the duration of a wave cycle
(subdividing this period of time into a convenient number of time steps),
since each instant will correspont to a phase position,
and these will repeat after the wave cycle is over
(so a single cycle is enough to cover all the phase positions).</p>

<p>One thing to keep in mind when summing these values is that,
because each oscillation in the pattern occurs over the same length of time,
and because the oscillations consist in the wave alternating between positive and negative values,
simply summing the interference pattern over a wave cycle
would result in zero everywhere. We need to make sure the values we're summing
actually accumulate, rather than cancel out.<p>

<p>Fortunately, what the holographic plate registers is <b>intensity, not amplitude</b>,
and intensity is proportional to the amplitude squared;
the squaring, conveniently, provides us with only positive values,
which can indeed be summed and accumulated properly.</p>

The cumulative interference pattern (i.e., the actual hologram) is thus obtained by:

\begin{equation}
holo(h) = \sum_t \left[ \sum_n A_n \cos(\omega t - k r_n(h)) + A_ʀ \cos ( \omega t - k p_ʀ(h)) \right]^2
	\label{eq:hologram}
\end{equation}

<p>This is all we need to make the hologram! Since we're talking about
computer-generated holograms, it is appropriate to present
the above equation in the form of a computer algorithm.
So, in pseudo-code, the final equation above translates to:</p>

<pre>
var timeSteps = 100
var holoPixels = 500
var objectPoints = [
      {x: ..., y: ..., z: ...},
      {x: ..., y: ..., z: ...},
      {x: ..., y: ..., z: ...} ]
var amplitude[], intensity[], hologram[]

for t = 0 --> timeSteps {
  ph = t/timeSteps * 2*pi  # wave phase, from 0 to 2pi
  for px = 0 --> holoPixels {
    amplitude[ px ] += ref-amplitude( px, ph )
    for each pt in objectPoints {
      amplitude[ px ] += obj-amplitude( px, ph, pt )
    }
    intensity[ px ] = amplitude[ px ]^2
  }
  hologram[] += intensity[]
}

# Normalize
hologram[] /= max( hologram[] )

# Auxiliary functions
ref-amplitude( px, ph ) {
  ...
}
obj-amplitude( px, ph, pt ) {
  ...
}
</pre>

<p>But this is a rather naive approach,
which not only introduces a loss of precision in the quantization of both space
(by dividing the object in points and the hologram surface in pixels)
and time (by dividing the phase space into discrete steps),
but also requires the calculation to range over a given length of time
— in other words, it essentially simulates an exposure period.</p>

In the next chapter, we will explore ways to make this calculation both more exact
and faster. <b><a href="pb-cgh-formulas-2.html">Onward!</a></b>

  </body>
</html>
